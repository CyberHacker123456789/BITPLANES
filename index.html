<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>BITPLANES - PHYSICS</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; display: flex; justify-content: center; align-items: center; }
        canvas { 
            image-rendering: pixelated; 
            width: 100vw; height: 100vh; 
            object-fit: contain;
            background: #4488ff;
        }
        #ui { position: absolute; color: #fff; font-family: 'Courier New', monospace; text-align: center; background: rgba(0,0,0,0.8); padding: 20px; z-index: 10; border: 2px solid #fff; }
        .hidden { display: none; }
    </style>
</head>
<body>

<div id="ui">
    <h1 style="margin:0; color:#ffff00;">BITPLANES</h1>
    <p>GRAVITY PHYSICS ENABLED</p>
    <button onclick="start()" style="padding:10px; cursor:pointer; font-family: 'Courier New'; font-weight:bold;">READY P1 & P2</button>
</div>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// Low-res internal buffer
const W = 400; const H = 240;
canvas.width = W; canvas.height = H;

const WORLD_W = 2400;
const GROUND_Y = 220;
const BARN_X = 1200;
const GRAVITY = 0.05;

const keys = {};
window.onkeydown = e => keys[e.code] = true;
window.onkeyup = e => keys[e.code] = false;

class Plane {
    constructor(x, y, color, controls, id) {
        this.id = id;
        this.startPos = {x, y};
        this.color = color;
        this.controls = controls;
        this.reset();
    }

    reset() {
        this.x = this.startPos.x; this.y = this.startPos.y;
        this.vx = 2; this.vy = 0;
        this.angle = 0;
        this.mode = 'flying'; // flying, falling, walking
        this.bullets = [];
        this.missiles = [];
        this.reload = 0;
        this.hp = 3;
    }

    update(target) {
        if (this.mode === 'flying') {
            // Physics: Steering affects velocity
            if (keys[this.controls.l]) this.angle -= 0.1;
            if (keys[this.controls.r]) this.angle += 0.1;

            // Engine Thrust
            let thrust = 0.15;
            this.vx += Math.cos(this.angle) * thrust;
            this.vy += Math.sin(this.angle) * thrust;

            // Gravity & Drag
            this.vy += GRAVITY;
            this.vx *= 0.98;
            this.vy *= 0.98;

            // Weaponry
            if (keys[this.controls.f] && this.reload <= 0) {
                this.bullets.push({x:this.x, y:this.y, vx: Math.cos(this.angle)*6, vy: Math.sin(this.angle)*6, t:40});
                this.reload = 10;
            }
            if (keys[this.controls.m] && this.reload <= 0) {
                this.missiles.push({x:this.x, y:this.y, a:this.angle, t:120});
                this.reload = 60;
            }

            // Ground Collision
            if (this.y > GROUND_Y - 5) {
                if (Math.abs(this.vy) < 1 && Math.abs(this.angle) < 0.5) {
                    this.vy = 0; this.y = GROUND_Y - 5; // Smooth Land
                } else {
                    this.mode = 'falling'; // Crash
                }
            }

            if (keys[this.controls.e]) this.mode = 'falling';

        } else if (this.mode === 'falling' || this.mode === 'chute') {
            if (keys[this.controls.e] && this.mode === 'falling') this.mode = 'chute';
            this.vy = this.mode === 'chute' ? 0.8 : 2.5;
            this.vx *= 0.95;
            if (this.y >= GROUND_Y - 2) { this.y = GROUND_Y - 2; this.mode = 'walking'; }
        } else if (this.mode === 'walking') {
            this.vx = 0;
            if (keys[this.controls.l]) this.vx = -1;
            if (keys[this.controls.r]) this.vx = 1;
            if (Math.abs(this.x - BARN_X) < 20) this.reset();
        }

        this.x += this.vx;
        this.y += this.vy;
        if (this.x < 0) this.x = WORLD_W; if (this.x > WORLD_W) this.x = 0;
        this.reload--;

        // Projectile movement
        this.bullets.forEach((b, i) => {
            b.x += b.vx; b.y += b.vy; b.t--;
            if (b.t < 0) this.bullets.splice(i, 1);
        });
        
        this.missiles.forEach((m, i) => {
            let angleTo = Math.atan2(target.y - m.y, target.x - m.x);
            let diff = angleTo - m.a;
            while (diff < -Math.PI) diff += Math.PI*2;
            while (diff > Math.PI) diff -= Math.PI*2;
            m.a += diff * 0.05;
            m.x += Math.cos(m.a) * 3.5;
            m.y += Math.sin(m.a) * 3.5;
            m.t--;
            if (m.t < 0) this.missiles.splice(i, 1);
        });
    }

    draw(c, cx, cy) {
        c.save();
        c.translate(this.x - cx, this.y - cy);
        c.fillStyle = this.color;
        if (this.mode === 'flying') {
            c.rotate(this.angle);
            c.fillRect(-6, -2, 12, 4); // Body
            c.fillRect(-1, -7, 2, 14); // Wings
            c.fillStyle = "#fff"; c.fillRect(4, -1, 3, 2); // Nose
        } else if (this.mode === 'walking' || this.mode === 'falling') {
            c.fillStyle = "#fff"; c.fillRect(-2, -6, 4, 6); // Pilot
        } else if (this.mode === 'chute') {
            c.fillStyle = "#fff"; c.fillRect(-6, -15, 12, 3); // Chute
            c.fillRect(-1, -6, 2, 6); // Character
        }
        c.restore();

        this.bullets.forEach(b => { c.fillStyle = "#ff0"; c.fillRect(b.x-cx, b.y-cy, 2, 2); });
        this.missiles.forEach(m => { c.fillStyle = "#f0f"; c.fillRect(m.x-cx, m.y-cy, 3, 3); });
    }
}

let p1, p2;

function start() {
    document.getElementById('ui').className = 'hidden';
    p1 = new Plane(400, 100, '#f00', {l:'KeyA', r:'KeyD', f:'KeyC', m:'KeyV', e:'KeyX'}, 1);
    p2 = new Plane(2000, 100, '#00f', {l:'ArrowLeft', r:'ArrowRight', f:'KeyN', m:'KeyM', e:'KeyB'}, 2);
    update();
}

function drawWorld(c, cx, cy) {
    // Ground
    c.fillStyle = "#22aa22"; c.fillRect(0, GROUND_Y - cy, W, 100);
    // Barn
    c.fillStyle = "#aa2222"; 
    c.fillRect(BARN_X - cx - 20, GROUND_Y - cy - 25, 40, 25);
    c.fillStyle = "#fff"; 
    c.fillRect(BARN_X - cx - 5, GROUND_Y - cy - 12, 10, 12);
}

function update() {
    p1.update(p2); p2.update(p1);
    ctx.clearRect(0,0,W,H);

    const dist = Math.abs(p1.x - p2.x);
    if (dist < 180) {
        // Zoomed in view
        let cx = (p1.x + p2.x)/2 - W/2;
        let cy = (p1.y + p2.y)/2 - H/2;
        drawWorld(ctx, cx, cy);
        p1.draw(ctx, cx, cy); p2.draw(ctx, cx, cy);
    } else {
        // Split Screen
        // P1
        ctx.save(); ctx.beginPath(); ctx.rect(0,0,W/2-1, H); ctx.clip();
        drawWorld(ctx, p1.x - W/4, p1.y - H/2);
        p1.draw(ctx, p1.x - W/4, p1.y - H/2);
        p2.draw(ctx, p1.x - W/4, p1.y - H/2);
        ctx.restore();
        // P2
        ctx.save(); ctx.translate(W/2+1, 0); ctx.beginPath(); ctx.rect(0,0,W/2, H); ctx.clip();
        drawWorld(ctx, p2.x - W/4, p2.y - H/2);
        p1.draw(ctx, p2.x - W/4, p2.y - H/2);
        p2.draw(ctx, p2.x - W/4, p2.y - H/2);
        ctx.restore();
        // Divider
        ctx.fillStyle = "#fff"; ctx.fillRect(W/2-1, 0, 2, H);
    }

    // Minimap
    ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.fillRect(2,2, 60, 15);
    ctx.fillStyle = p1.color; ctx.fillRect(2 + (p1.x/WORLD_W)*60, 8, 2, 2);
    ctx.fillStyle = p2.color; ctx.fillRect(2 + (p2.x/WORLD_W)*60, 8, 2, 2);

    requestAnimationFrame(update);
}
</script>
</body>
</html>
